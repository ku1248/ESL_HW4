github : https://github.com/ku1248/ESL_HW1
General description or introduction of the problem and your solutionï¼š
  Homework 1 required us to do Gaussian blur filter with sending or receiving data in a row-based fashion. In Lab 2 we have finished sobel filter but without row-based fashion. Since Gaussian blur filter can implement similar to sobel filter, we should fix how we send and receive data ,and also fix the filter from sobel to Gaussian blur. The solution I use is to read image pixels row by row and save them into buffer in Testbench first. And then send them to Gaussian blur filter in order. While sending pixels in order, Gaussian blur filter can finish calculation in correct order. Repeating this process, we can finish Gaussian blur to whole image.
Implementation details (data structure, flows and algorithms) :
  Since we have to send and receive data in row-based fashion. I create buffers in Testbench to save the image pixel data for rows. And the buffer size I use is 3 * 256 for R, G, and B. The reason why it is 3 * 256 is that 3 is the number of rows required to do one row of Gaussian blur and 256 is the number of image width. I will receive the pixels of first two rows of original image and send them into buffer with 256 cycles each row. It is because we only need two rows of pixels to get the result of Gaussian blur for first row. Since we have the pixel data of two rows, writing them in order into FIFO can do Gaussian blur correctly. And then while doing the calculation of first row, I send the third row of image data to buffer preparing for next row calculation. For the rest of the image, I first send the pixel data needed for each row to do Gaussian blur into FIFOs first in Testbench. And after all the data are sent in correct order into FIFOs, I send the pixel data of next row into buffer in 256 cycles, replacing the pixel data of the row that we don't need anymore. One point to notice is that because we replace the row that we don't need in buffer, so the pixel data in buffer will not always in order. So I write some conditional statement to decide how to send data to FIFO in correct order.
Additional features of your design and models :
  I changed the sobel filter in Lab 2 into Gaussian blur filter. Since the result of Gaussian blur filter is not grey scale. I added some new FIFOs to transfer the result of Gaussian blur for R, G, and B. And also, I used row buffer to save row pixels to prevent sending or receiving the same data repeatly.
Experimental results (on different benchmarks and settings) :
  The Gaussian blur filter works correctly since the result image comparing to original image is blurred. However, in order to implement it in row-based fashion, I spend additional cycles to send pixel row data into buffers. So the simulated time (720642 ns) compared to sobel filter (655358 ns) is longer but we saved the data transfer of repeated data.
Discussions and conclusions :
  Since homework 1 and Lab 2 are both implementing filter to image, so I discuss them together. In Lab 2, for each 9 cycles, Testbench receive and send 9 pixel of data into FIFOs. But for the 9 pixels sent, the 6 pixels of them are same as the pixels that we have received and sent already. So, in homework 1, I send the pixels of a row into buffers and send them into FIFOs in order. The advantage of this method is to prevent receiving the same pixel data repeatly. The pixel transfered in Lab 2 is about 9 * 256 * 256, however, in homework 1, using row-based fashion, the pixel transfered is just 256 * 256. The conclusion is that in this homework, I saved the data transfer about (1 / 9) although I may spend some additional time reading row pixel data.